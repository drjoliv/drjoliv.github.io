---
layout: post
category : [desonte-jolivet, short]
description: "Solutions to the first five Euler problems using jFunc."
tagline: "The first five euler problems."
---

The first five Euler problems. All the Euler problems are solved using a Java library I'm working on called [jFunc](https://github.com/drjoliv/jfunc), which implements many functional programming concepts.

<!--excerpt-->

* [Euler 01](#euler-01)
* [Euler 02](#euler-02)
* [Euler 03](#euler-03)
* [Euler 04](#euler-04)
* [Euler 05](#euler-05)

<hr/>
## Euler 01

> If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.

Loops are seen throughout mathematics and computer science. The first code snippet shows the use of a plain old for loop, each iteration of the plain old for loop counter is incremented and its divisibility is checked if the number is divisble by 3 or 5 its added to the overall sum.

```java
  int sum = 0;
  for(int i = 1; i > 1000; i++) {
    if(i % 3 == 0 || i % 5 == 0)
      sum += i;
  }
```

We can abstract over the idea of a loop with a list of numbers, each number in the list represents an iteration of the loop. The below code snippet uses [jFunc](https://github.com/drjoliv/jfunc) instead of a plain old for loop. The functions [range(int from, int to)](https://drjoliv.github.io/jfunc/drjoliv/jfunc/nums/Integers.html#range-java.lang.Integer-java.lang.Integer-) creates a list of integers between `from` and `to` where `from` and `to` are inclusive. The method [filter(P1&lt;A&gt; predicate)](https://drjoliv.github.io/jfunc/drjoliv/jfunc/data/list/FList.html#filter-drjoliv.jfunc.function.P1-) uses the given predicate to test each element within the list and removes elements that fail that test. The [foldr(F2&lt;B,A,B&gt; fn, B b)](https://drjoliv.github.io/jfunc/drjoliv/jfunc/data/list/FList.html#foldr-drjoliv.jfunc.function.F2-B-) reduces the list into a single value representing the sum of all the multiples of 3 and 5 below 1000. Declarative code really gets me going and is the reason I'm so interested in functional programming and like most list types in functional languages the sequential list type in [jFunc](https://github.com/drjoliv/jfunc) is also lazy.


```java
FList<Integer> list = range(1,999) // 
              .filter(i -> i % 3 == 0 || i % 5 == 0);
return list.foldr(Integers::add, 0);
```
[Complete Code](https://github.com/drjoliv/ProjectEulerSolutions/blob/master/src/main/java/drjoliv/euler/Euler01.java) |
<a type="button" data-toggle="collapse" data-target="#euler01" aria-expanded="false" aria-controls="euler01">
Answer
</a>
<div class="collapse" id="euler01">
  <div class="well well-sm">233168</div>
</div>

<hr/>

## Euler 02

> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

```java
FList<Integer> list = FList.sequence(1,2, Integers::add) // 1, 2, 3, 5, 8, 12, 20 ...
  .filter(i -> i % 2 == 0)
  .takeWhile(i -> i < 4000000);
return list.foldr(Integers::add,0);
```

In many sequences, the next element in a sequence is determined by the previous elements in the sequence. [sequence(A a1, A a2, F2&lt;A, A, A&gt; fn)](https://drjoliv.github.io/jfunc/drjoliv/jfunc/data/list/FList.html#sequence-A-A-drjoliv.jfunc.function.F2-) follows this idea `a1` and `a2` are the first two elements of the sequence and `fn` is a function that takes the previous two elements and produces the next element. [filter(P1&lt;A&gt; predicate)](https://drjoliv.github.io/jfunc/drjoliv/jfunc/data/list/FList.html#filter-drjoliv.jfunc.function.P1-) removes any Fibnoacci numbers that are not even. [takeWhile(P1&lt;A&gt; predicate)](https://drjoliv.github.io/jfunc/drjoliv/jfunc/data/list/FList.html#takeWhile-drjoliv.jfunc.function.P1-) will take elements from the list as long as the `predicate` is true when the `predicate` is false the remaining elements in the list are  dropped. `sequence`, `filter`, and `takeWhile` all return a type of [FList](https://drjoliv.github.io/jfunc/drjoliv/jfunc/data/list/FList.html) which allows use to create fluent and readable code. On my Intel® Core™ i5-3339Y CPU @ 1.50GHz × 4, this computes in 0.076 seconds, which is fast enough for me.

[Complete Code](https://github.com/drjoliv/ProjectEulerSolutions/blob/master/src/main/java/drjoliv/euler/Euler02.java) |
<a type="button" data-toggle="collapse" data-target="#euler02" aria-expanded="false" aria-controls="euler02">
Answer
</a>
<div class="collapse" id="euler02">
  <div class="well well-sm">4613732</div>
</div>

<hr/>
## Euler 03

> The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143 ?

```java
FList<Long> primes = Numbers.primeFactors(600851475143L);
return primes.maximum(Long::compare);
```

 [jFunc](https://github.com/drjoliv/jfunc) inlcudes a function that returns all the prime factors of a number [primeFactors(long num)](https://drjoliv.github.io/jfunc/drjoliv/jfunc/nums/Numbers.html#primeFactors-java.lang.Long-) and FList contains the method [maximum](https://drjoliv.github.io/jfunc/drjoliv/jfunc/foldable/Foldable.html#maximum-java.util.Comparator-) which returns the maximum number in a list. This makes the solution a nice two liner.

[Complete Code](https://github.com/drjoliv/ProjectEulerSolutions/blob/master/src/main/java/drjoliv/euler/Euler03.java) |
<a type="button" data-toggle="collapse" data-target="#euler03" aria-expanded="false" aria-controls="euler03">
Answer
</a>
<div class="collapse" id="euler03">
  <div class="well well-sm">6857</div>
</div>

<hr/>
## Euler 04

> A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99. Find the largest palindrome made from the product of two 3-digit numbers.

I didn't think about this too hard, I just created a function that checks if a list of values is a palindrome. With my generic function, I ignored any fancy ways to check if an integer is a palindrome and decided to just convert each integer into a list of characters then used `isPalindrome` to check if it was indeed a palindrome. Two things to note that are unique, first the method [visit(F1&lt;Unit, B&gt; nil, F2&lt;A, FList&lt;A&gt;, B&gt; cons)](https://drjoliv.github.io/jfunc/drjoliv/jfunc/data/list/FList.html#visit-drjoliv.jfunc.function.F1-drjoliv.jfunc.function.F2-) which return a value of type `B` and takes two functions. `visit` returns the value computed by `nil` or `cons`, which computed valued returned depends on if the [FList](https://drjoliv.github.io/jfunc/drjoliv/jfunc/data/list/FList.html) on which `visit` is called on is empty. If the [FList](https://drjoliv.github.io/jfunc/drjoliv/jfunc/data/list/FList.html) is empty then the first function `nil` is used otherwise `cons` is used. The values passed to `cons` are the head and tail of the list visit is called on. The second interesting piece of code is [caseOf(A a)](https://drjoliv.github.io/jfunc/drjoliv/jfunc/contorl/CaseOf.html#caseOf-A-), which is a beefed up switch statement. The function `of` takes a predicated and a supplier which yields a value. When the predicated passed to `of` is true the computed value supplier given to `of` is the value returned by the `CaseOf`.

```java
  public static <A> boolean isPalindrome(FList<A> chars) {
    return chars.visit(n -> true
          , (h,t) -> {
            return CaseOf.caseOf(t)
              .of(FList::isEmpty, () -> true)
              .of(sizeOf(1),      () -> h == t.head())
              .of(lastEq(h),      l  ->  isPalindrome(l.init()))
              .otherwise(() -> false);
          });
  }
```

The [For(F1&lt;A, ? extends Monad&lt;FList.μ, A&gt;&gt;, F2&lt;A, B, ? extends Monad&lt;FList.μ, A&gt;&gt; )](https://drjoliv.github.io/jfunc/drjoliv/jfunc/data/list/FList.html#For-drjoliv.jfunc.function.F1-drjoliv.jfunc.function.F2-) method sequences monadic operations and is analogous to a do-block in Haskell. [guard(boolean b)](https://drjoliv.github.io/jfunc/drjoliv/jfunc/data/list/Functions.html#guard-boolean-) returns an empty FList if `b` is false and FList&lt;Unit&gt; otherwise.

```java
  public static int euler04() {
    Show<Integer> s = Show.showInt(); //Show<Integer> converts an Integer into a list of Characters.
    FList<Integer> l =
      range(100, 999)
      .For(a    -> range(a, 999)
         ,(a,b) -> { 
           int p = a * b;
           return guard(isPalindrome(s.show(p))).semi(flist(p)); //semi is bind but ignores the value within the monad being binded over.
         });
    return l.maximum(Integer::compare);
  }
```

[Complete Code](https://github.com/drjoliv/ProjectEulerSolutions/blob/master/src/main/java/drjoliv/euler/Euler04.java) |
<a type="button" data-toggle="collapse" data-target="#euler04" aria-expanded="false" aria-controls="euler04">
Answer
</a>
<div class="collapse" id="euler04">
  <div class="well well-sm">906609</div>
</div>

<hr/>
## Euler 05

> 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

[lcm](https://drjoliv.github.io/jfunc/drjoliv/jfunc/nums/Longs.html#lcm-long-long-) is a function of arity two that takes two numbers and returns the least common multiple of those two numbers. `lcm` is a very straightforward function and the details of how to implement it can be found [here](https://en.wikipedia.org/wiki/Least_common_multiple). Whats more interesting about `lcm` is the fact that its associative and commutative, that is `lcm(lcm(2,3),4) == lcm(2, lcm(3,4)) == lcm(4, lcm(2,3)) == 12`. Because of this, we can simply fold over a least of numbers to find the least common multiple of all those numbers.

```java
    return range(1L,20L).foldr(Longs::lcm,1L);
```

[Complete Code](https://github.com/drjoliv/ProjectEulerSolutions/blob/master/src/main/java/drjoliv/euler/Euler05.java) |<a type="button" data-toggle="collapse" data-target="#euler05" aria-expanded="false" aria-controls="euler05">
Answer
</a>
<div class="collapse" id="euler05">
  <div class="well well-sm">232792560</div>
</div>

